<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- PWA manifest & theme color -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0097a7">
  <!-- iOS support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  <title>Novelist Tools</title>
  <style>
    /* Common reset & fonts */
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      margin: 0; padding: 0;
      background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
      color: #e0e0e0;
      -webkit-font-smoothing: antialiased;
      font-size: 16px; line-height: 1.6;
    }
    header {
      display: flex; align-items: center;
      background: #111; padding: 15px 20px;
      position: sticky; top: 0; z-index: 10;
    }
    .menu-toggle {
      font-size: 24px; cursor: pointer; margin-right: 20px;
    }
    .title {
      font-size: 20px; font-weight: bold; color: #fff;
    }

    /* Sidebar on right, fully hidden via transform when closed */
    .sidebar {
      position: fixed;
      top: 0; right: 0;
      width: 240px; height: 100%;
      background: #222; padding: 20px;
      box-shadow: -2px 0 8px rgba(0,0,0,0.5);
      transform: translateX(100%);  /* start fully off-screen to the right */
      transition: transform 0.3s ease;
      z-index: 20;
      overflow-y: auto;
    }
    .sidebar.open {
      transform: translateX(0);    /* slide into view */
    }
    .sidebar h2 {
      color: #fff; margin-top: 0; margin-bottom: 20px;
    }
    .sidebar button {
      width: 100%; margin-bottom: 15px; padding: 12px;
      border: none; border-radius: 8px;
      background: linear-gradient(135deg, #26c6da, #0097a7);
      color: #fff; font-size: 16px; cursor: pointer;
      transition: all 0.3s;
    }
    .sidebar button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(255,255,255,0.1);
    }

    .container {
      max-width: 480px; margin: 20px auto; padding: 0 20px;
    }
    /* Shared card style */
    .card {
      background: linear-gradient(145deg, #2a2a2a, #202020);
      padding: 30px; border-radius: 18px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 2px 6px rgba(0,0,0,0.2);
    }
    h1 {
      color: #fff; text-align: center;
      font-size: 28px; margin-bottom: 25px;
      text-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    /* Buttons */
    .btn {
      width: 100%; max-width: 340px; margin: 10px auto;
      padding: 14px 30px; border: none; border-radius: 12px;
      cursor: pointer; font-size: 16px; font-weight: 500;
      text-align: center; text-decoration: none; color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s cubic-bezier(0.25,0.8,0.25,1);
      display: block; box-sizing: border-box;
    }
    .btn:disabled {
      opacity: 0.6; cursor: not-allowed; transform: none;
      box-shadow: none;
    }

    /* EPUB Splitter specific */
    .upload-btn {
      background: linear-gradient(135deg, #7e57c2, #5e37b5);
    }
    .split-btn {
      background: linear-gradient(135deg, #26c6da, #0097a7);
    }
    .download-btn {
      background: linear-gradient(135deg, #ff7043, #e64a19);
    }
    .mode-section, .options-section {
      text-align: center; margin-bottom: 25px;
    }
    .mode-section select, .option-group input {
      background: #2e2e2e; border: 2px solid transparent;
      border-radius: 8px; padding: 12px; font-size: 14px;
      color: #e0e0e0; transition: border-color 0.3s, box-shadow 0.3s;
      width: 100%; max-width: 300px; margin: 10px auto 0;
    }
    .option-group {
      margin-bottom: 15px;
    }
    .option-group label {
      font-weight: 500; color: #ffffffcc;
      display: block; margin-bottom: 8px;
    }
    .spinner, .spinner-backup {
      border: 5px solid rgba(255,255,255,0.1);
      border-top: 5px solid #4a90e2;
      border-radius: 50%; width: 45px; height: 45px;
      animation: spin 1.2s cubic-bezier(0.5,0,0.5,1) infinite;
      margin: 20px auto; display: none;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #statusMessage {
      border-radius: 10px; padding: 16px;
      position: relative; animation: slideIn 0.3s ease-out;
      margin-top: 20px;
    }
    @keyframes slideIn {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    /* Backup Utility specific */
    .operation-selector, .operation-section {
      margin-bottom: 25px;
    }
    label {
      display: block; color: #ffffffcc;
      font-weight: 500; margin-bottom: 8px;
    }
    select, input[type="text"], input[type="number"],
    input[type="file"], textarea {
      width: 100%; padding: 12px; margin-bottom: 15px;
      background: #2e2e2e; border: 2px solid transparent;
      border-radius: 8px; color: #e0e0e0; font-size: 14px;
      box-sizing: border-box; transition: border-color 0.3s, box-shadow 0.3s;
    }
    textarea {
      resize: vertical; min-height: 80px;
    }
    .btn-primary {
      background: linear-gradient(135deg, #26c6da, #0097a7);
    }
    .btn-accent {
      background: linear-gradient(135deg, #7e57c2, #5e37b5);
    }
    .status-toast {
      position: fixed; bottom: 20px; left: 50%;
      transform: translateX(-50%);
      padding: 14px 24px; border-radius: 8px;
      color: #fff; font-size: 14px;
      opacity: 0; pointer-events: none;
      transition: opacity 0.3s ease-in-out; z-index: 1000;
    }
    .toast-success {
      background: #38a86d;
    }
    .toast-error {
      background: #ff6b6b;
    }
  </style>
</head>
<body>

  <header>
    <div class="menu-toggle" onclick="toggleMenu()">â˜°</div>
    <div class="title" id="appTitle">EPUB Chapter Splitter</div>
  </header>

  <div class="sidebar" id="sidebar">
    <h2>Select Tool</h2>
    <button onclick="switchApp('splitter')">EPUB Chapter Splitter</button>
    <button onclick="switchApp('backup')">Novel Backup Utility</button>
  </div>

  <div class="container">
    <!-- EPUB Chapter Splitter -->
    <div id="splitterApp" class="card">
      <h1>EPUB Chapter Splitter</h1>
      <div class="upload-section">
        <label for="epubUpload" class="btn upload-btn">Upload EPUB File</label>
        <input type="file" id="epubUpload" accept=".epub" style="display:none;">
        <div id="epubFileName" style="margin-top:10px;font-size:14px;color:#cccccc;text-align:center;"></div>
      </div>
      <div class="mode-section">
        <label for="modeSelect">Output Mode:</label>
        <select id="modeSelect">
          <option value="single">Single Chapter per File</option>
          <option value="grouped">Grouped Chapters per File</option>
        </select>
      </div>
      <div class="options-section">
        <div class="option-group">
          <label for="chapterPattern">Chapter Prefix:</label>
          <input type="text" id="chapterPattern" placeholder="e.g., test" value="test">
        </div>
        <div class="option-group">
          <label for="startNumber">Start Number:</label>
          <input type="number" id="startNumber" min="1" value="1">
        </div>
        <div class="option-group" id="groupSizeGroup" style="display:none;">
          <label for="groupSize">Chapters per File:</label>
          <input type="number" id="groupSize" min="1" value="4">
        </div>
      </div>
      <button id="splitBtn" class="btn split-btn" disabled>Split EPUB</button>
      <div id="spinnerSplitter" class="spinner"></div>
      <div id="statusMessage" class="status" style="display:none;"></div>
      <div class="download-section" style="display:none;">
        <a id="downloadLink" class="btn download-btn">Download Chapters</a>
      </div>
    </div>

    <!-- Novel Backup File Utility -->
    <div id="backupApp" class="card" style="display:none;">
      <h1>Novel Backup File Utility</h1>
      <div class="operation-selector">
        <label for="operationSelect">Select Operation:</label>
        <select id="operationSelect">
          <option value="create">Create New Backup File</option>
          <option value="extend">Extend Existing Backup File</option>
          <option value="merge">Merge Backup Files</option>
          <option value="findReplace">Find & Replace</option>
        </select>
      </div>

      <div id="createSection" class="operation-section">
        <h2>Create New Backup File</h2>
        <label for="createProjectTitle">Project Title:</label>
        <input type="text" id="createProjectTitle" placeholder="Enter project title">
        <label for="createDescription">Description:</label>
        <textarea id="createDescription" placeholder="Enter project description"></textarea>
        <label for="createUniqueCode">Unique Code (Optional):</label>
        <input type="text" id="createUniqueCode" placeholder="Leave blank to generate automatically">
        <label for="createChapters">Number of Chapters:</label>
        <input type="number" id="createChapters" min="1" value="3">
        <label for="createPrefix">Prefix for Chapter Titles:</label>
        <input type="text" id="createPrefix" placeholder="e.g., Chapter ">
        <label for="createTOC">Show Table of Contents:</label>
        <select id="createTOC">
          <option value="true">True</option>
          <option value="false">False</option>
        </select>
        <label for="createIndentation">Automatic Indentation:</label>
        <select id="createIndentation">
          <option value="true">True</option>
          <option value="false">False</option>
        </select>
        <button id="createBtn" class="btn btn-primary">Generate and Download</button>
      </div>

      <div id="extendSection" class="operation-section" style="display:none;">
        <h2>Extend Existing Backup File</h2>
        <label for="extendBackupFile">Upload Backup File:</label>
        <input type="file" id="extendBackupFile" accept=".json,.txt">
        <label for="extendExtraChapters">Extra Empty Chapters:</label>
        <input type="number" id="extendExtraChapters" min="1" value="200">
        <label for="extendPrefix">Prefix for New Chapters:</label>
        <input type="text" id="extendPrefix" placeholder="e.g., Chapter ">
        <button id="extendBtn" class="btn btn-primary">Extend and Download</button>
      </div>

      <div id="mergeSection" class="operation-section" style="display:none;">
        <h2>Merge Backup Files</h2>
        <label for="mergeProjectTitle">Merged Project Title:</label>
        <input type="text" id="mergeProjectTitle" placeholder="Enter merged project title">
        <label for="mergeDescription">Merged Description:</label>
        <textarea id="mergeDescription" placeholder="Enter merged project description"></textarea>
        <label for="mergeBackupFiles">Upload Backup Files:</label>
        <input type="file" id="mergeBackupFiles" accept=".json,.txt" multiple>
        <label for="mergePrefix">Prefix for Chapters:</label>
        <input type="text" id="mergePrefix" placeholder="e.g., Chapter ">
        <button id="mergeBtn" class="btn btn-primary">Merge and Download</button>
      </div>

      <div id="findReplaceSection" class="operation-section" style="display:none;">
        <h2>Find & Replace in Backup File</h2>
        <label for="frBackupFile">Upload Backup File:</label>
        <input type="file" id="frBackupFile" accept=".json,.txt">
        <label for="findPattern">Find Pattern:</label>
        <input type="text" id="findPattern" placeholder="Enter search term or regex">
        <label for="replaceText">Replacement Text:</label>
        <input type="text" id="replaceText" placeholder="Enter replacement text">
        <label><input type="checkbox" id="useRegex"> Use Regular Expressions</label>
        <div style="display:flex; gap:10px; margin:15px 0;">
          <button id="findPreviousBtn" class="btn btn-primary">Find Previous</button>
          <button id="findNextBtn" class="btn btn-primary">Find Next</button>
        </div>
        <div style="display:flex; gap:10px; margin-bottom:15px;">
          <button id="replaceNextBtn" class="btn btn-primary">Replace This</button>
          <button id="replaceAllBtn" class="btn btn-primary">Replace All & Download</button>
        </div>
        <div id="currentMatchDisplay" style="background:#2e2e2e; padding:12px; border-radius:8px; min-height:50px; white-space:pre-wrap; color:#e0e0e0;">
          No match found yet.
        </div>
      </div>

      <div id="spinnerBackup" class="spinner-backup"></div>
    </div>
  </div>

  <div id="toast" class="status-toast"></div>

  <!-- JSZip for EPUB parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    // Toggle sidebar
    function toggleMenu() {
      document.getElementById('sidebar').classList.toggle('open');
    }
    function switchApp(app) {
      document.getElementById('splitterApp').style.display = app === 'splitter' ? 'block' : 'none';
      document.getElementById('backupApp').style.display   = app === 'backup'  ? 'block' : 'none';
      document.getElementById('appTitle').textContent      = app === 'splitter'
        ? 'EPUB Chapter Splitter'
        : 'Novel Backup File Utility';
      toggleMenu();
    }

    // EPUB Splitter Logic
    document.addEventListener('DOMContentLoaded', () => {
      const uploadInput   = document.getElementById('epubUpload');
      const fileNameEl    = document.getElementById('epubFileName');
      const splitBtn      = document.getElementById('splitBtn');
      const modeSelect    = document.getElementById('modeSelect');
      const groupSizeGrp  = document.getElementById('groupSizeGroup');
      const spinnerSpl    = document.getElementById('spinnerSplitter');
      const statusEl      = document.getElementById('statusMessage');
      const downloadSec   = document.querySelector('#splitterApp .download-section');
      const downloadLink  = document.getElementById('downloadLink');
      let selectedFile    = null;

      uploadInput.addEventListener('change', e => {
        selectedFile = e.target.files[0];
        if (selectedFile) {
          fileNameEl.textContent = `Selected: ${selectedFile.name}`;
          splitBtn.disabled = false;
          statusEl.style.display = 'none';
          downloadSec.style.display = 'none';
        }
      });
      modeSelect.addEventListener('change', () => {
        groupSizeGrp.style.display = modeSelect.value === 'grouped' ? 'block' : 'none';
      });

      splitBtn.addEventListener('click', () => {
        if (!selectedFile) return;
        spinnerSpl.style.display = 'block';
        statusEl.style.display = 'none';
        downloadSec.style.display = 'none';

        readFileAsArrayBuffer(selectedFile)
          .then(buffer => JSZip.loadAsync(buffer))
          .then(epub => {
            const structure = {};
            const promises = [];
            epub.forEach((path, file) => {
              structure[path] = { dir: file.dir, contentType: file.options.contentType };
              if (!file.dir && /\.(xhtml|html)$/.test(path) || /(?:content\.opf|toc\.ncx)/.test(path)) {
                promises.push(file.async('text').then(c => structure[path].content = c));
              }
            });
            return Promise.all(promises).then(() => structure);
          })
          .then(structure => {
            const chapters = [];
            for (let path in structure) {
              const info = structure[path];
              if (!info.dir && info.content) {
                const parser = new DOMParser();
                let doc = parser.parseFromString(info.content, 'text/xml');
                if (doc.querySelector('parsererror')) {
                  doc = parser.parseFromString(info.content, 'text/html');
                }
                const sections = doc.querySelectorAll(
                  'section[epub\\:type="chapter"], div[epub\\:type="chapter"], ' +
                  'section.chapter, div.chapter, section[role="chapter"], div[role="chapter"]'
                );
                if (sections.length) {
                  sections.forEach(sec => {
                    sec.querySelectorAll('h1,h2,h3,.title,.chapter-title').forEach(el => el.remove());
                    const paras = sec.querySelectorAll('p');
                    const text = paras.length
                      ? Array.from(paras).map(p => p.textContent.trim()).filter(t => t).join('\n')
                      : sec.textContent.replace(/\s*\n\s*/g, '\n').trim();
                    if (text) chapters.push(text);
                  });
                } else {
                  const headings = doc.querySelectorAll('h1,h2,h3');
                  if (headings.length > 1) {
                    for (let i = 0; i < headings.length; i++) {
                      let node = headings[i].nextSibling, content = '';
                      while (node && !(node.nodeType === 1 && /H[1-3]/.test(node.tagName))) {
                        content += node.nodeType === 1 ? node.textContent + '\n' : node.textContent;
                        node = node.nextSibling;
                      }
                      content = content.replace(/\n{3,}/g, '\n').trim();
                      if (content) chapters.push(content);
                    }
                  }
                }
              }
            }
            return chapters;
          })
          .then(chapters => {
            if (!chapters.length) throw new Error('No chapters found. Check EPUB structure.');
            const pattern = document.getElementById('chapterPattern').value.trim() || 'chapter';
            let start     = parseInt(document.getElementById('startNumber').value, 10) || 1;
            const mode    = modeSelect.value;
            const zip     = new JSZip();

            if (mode === 'single') {
              chapters.forEach((ch, i) => {
                const num = String(start + i).padStart(2, '0');
                zip.file(`${pattern}${num}.txt`, ch);
              });
            } else {
              let groupSize = parseInt(document.getElementById('groupSize').value, 10) || 1;
              for (let i = 0; i < chapters.length; i += groupSize) {
                const s = start + i;
                const e = Math.min(start + i + groupSize - 1, start + chapters.length - 1);
                const name = s === e
                  ? `${pattern} C${String(s).padStart(2, '0')}.txt`
                  : `${pattern} C${String(s).padStart(2, '0')}-${String(e).padStart(2, '0')}.txt`;
                let content = '';
                for (let j = 0; j < groupSize && i + j < chapters.length; j++) {
                  if (j > 0) content += '\n---------------- END ----------------\n';
                  content += chapters[i + j];
                }
                zip.file(name, content);
              }
            }

            return zip.generateAsync({ type: 'blob' });
          })
          .then(blob => {
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.download = `${document.getElementById('chapterPattern').value || 'chapter'}_chapters.zip`;
            document.querySelector('#splitterApp .download-section').style.display = 'block';
            statusEl.textContent = 'Successfully extracted chapters.';
            statusEl.className = 'status success';
            statusEl.style.display = 'block';
          })
          .catch(err => {
            statusEl.textContent = `Error: ${err.message}`;
            statusEl.className = 'status error';
            statusEl.style.display = 'block';
          })
          .finally(() => {
            spinnerSpl.style.display = 'none';
          });
      });

      function readFileAsArrayBuffer(file) {
        return new Promise((res, rej) => {
          const r = new FileReader();
          r.onload  = () => res(r.result);
          r.onerror = () => rej(new Error('Failed to read file'));
          r.readAsArrayBuffer(file);
        });
      }
    });

    // Backup Utility Logic
    document.addEventListener('DOMContentLoaded', () => {
      const toastEl = document.getElementById('toast');
      function showToast(msg, isError = false) {
        toastEl.textContent = msg;
        toastEl.className = 'status-toast ' + (isError ? 'toast-error' : 'toast-success');
        toastEl.style.opacity = '1';
        setTimeout(() => { toastEl.style.opacity = '0'; }, 3000);
      }
      const spinnerB = document.getElementById('spinnerBackup');
      function setSpinner(on) { spinnerB.style.display = on ? 'block' : 'none'; }

      // Switch operation sections
      const opSelect = document.getElementById('operationSelect');
      opSelect.addEventListener('change', () => {
        ['create','extend','merge','findReplace'].forEach(op => {
          document.getElementById(op + 'Section').style.display =
            opSelect.value === op ? 'block' : 'none';
        });
      });

      // Create new backup
      document.getElementById('createBtn').addEventListener('click', () => {
        setSpinner(true);
        try {
          const title      = document.getElementById('createProjectTitle').value;
          const desc       = document.getElementById('createDescription').value;
          const codeInput  = document.getElementById('createUniqueCode').value.trim();
          const count      = parseInt(document.getElementById('createChapters').value, 10) || 0;
          const prefix     = document.getElementById('createPrefix').value;
          const showTOC    = document.getElementById('createTOC').value === 'true';
          const autoIndent = document.getElementById('createIndentation').value === 'true';
          if (!title || !desc || count < 1) throw new Error('Please fill title, description, and at least 1 chapter.');

          const uniqueCode = codeInput ||
            Math.floor(Math.random() * 0xFFFFFFFF).toString(16).padStart(8, '0');
          const now = Date.now();
          const scenes   = [];
          const sections = [];
          for (let i = 1; i <= count; i++) {
            const chap = prefix ? prefix + i : i.toString();
            scenes.push({
              code: 'scene' + i, title: chap,
              text: JSON.stringify({ blocks: [{ type: 'text', align: 'left', text: '' }] }),
              ranking: i, status: '1'
            });
            sections.push({
              code: 'section' + i, title: chap,
              synopsis: '', ranking: i,
              section_scenes: [{ code: 'scene' + i, ranking: 1 }]
            });
          }
          const backup = {
            version: 4, code: uniqueCode, title, description: desc,
            show_table_of_contents: showTOC,
            apply_automatic_indentation: autoIndent,
            last_update_date: now, last_backup_date: now,
            revisions: [{
              number: 1, date: now,
              book_progresses: [{
                year: new Date().getFullYear(),
                month: new Date().getMonth() + 1,
                day: new Date().getDate(),
                word_count: 0
              }],
              statuses: [{ code: '1', title: 'Todo', color: -2697255, ranking: 1 }],
              scenes, sections
            }]
          };
          const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
          const url  = URL.createObjectURL(blob);
          const a    = document.createElement('a');
          a.href     = url;
          a.download = 'new_backup_file.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showToast('Backup file created');
        } catch (err) {
          showToast(err.message, true);
        } finally {
          setSpinner(false);
        }
      });

      // Extend existing backup
      document.getElementById('extendBtn').addEventListener('click', () => {
        const inp = document.getElementById('extendBackupFile');
        if (!inp.files.length) {
          showToast('Please upload a backup file.', true);
          return;
        }
        setSpinner(true);
        const extra  = parseInt(document.getElementById('extendExtraChapters').value, 10) || 0;
        const prefix = document.getElementById('extendPrefix').value;
        const reader = new FileReader();
        reader.onerror = () => {
          showToast('Error reading file.', true);
          setSpinner(false);
        };
        reader.onload = e => {
          try {
            const backup = JSON.parse(e.target.result);
            const rev    = backup.revisions?.[0];
            if (!rev) throw new Error('Invalid backup structure.');
            const existing = rev.scenes?.length || 0;
            for (let i = 1; i <= extra; i++) {
              const num  = existing + i;
              const chap = prefix ? prefix + num : num.toString();
              rev.scenes.push({
                code: 'scene' + num, title: chap,
                text: JSON.stringify({ blocks: [{ type: 'text', align: 'left', text: '' }] }),
                ranking: num, status: '1'
              });
              rev.sections.push({
                code: 'section' + num, title: chap,
                synopsis: '', ranking: num,
                section_scenes: [{ code: 'scene' + num, ranking: 1 }]
              });
            }
            const now = Date.now();
            backup.last_update_date = now;
            backup.last_backup_date = now;
            rev.date = now;
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = 'extended_backup_file.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Backup extended');
          } catch (err) {
            showToast(err.message, true);
          } finally {
            setSpinner(false);
          }
        };
        reader.readAsText(inp.files[0]);
      });

      // Merge backup files
      async function mergeBackupFiles(files, prefix) {
        let scenes   = [];
        let sections = [];
        for (let f of files) {
          const data = JSON.parse(await f.text());
          const rev  = data.revisions?.[0];
          if (rev?.scenes)    scenes   = scenes.concat(rev.scenes);
          if (rev?.sections)  sections = sections.concat(rev.sections);
        }
        scenes.forEach((s, i) => {
          const n = i + 1, t = prefix ? prefix + n : n.toString();
          s.code    = 'scene' + n;
          s.title   = t;
          s.ranking = n;
        });
        sections.forEach((s, i) => {
          const n = i + 1, t = prefix ? prefix + n : n.toString();
          s.code    = 'section' + n;
          s.title   = t;
          s.ranking = n;
          if (s.section_scenes?.[0]) {
            s.section_scenes[0].code    = 'scene' + n;
            s.section_scenes[0].ranking = 1;
          }
        });
        const now = Date.now();
        return {
          version: 4,
          code: Math.floor(Math.random() * 0xFFFFFFFF).toString(16).padStart(8, '0'),
          title: document.getElementById('mergeProjectTitle').value,
          description: document.getElementById('mergeDescription').value,
          show_table_of_contents: true,
          apply_automatic_indentation: true,
          last_update_date: now,
          last_backup_date: now,
          revisions: [{
            number: 1, date: now,
            statuses: [{ code: '1', title: 'Todo', color: -2697255, ranking: 1 }],
            scenes, sections
          }]
        };
      }

      document.getElementById('mergeBtn').addEventListener('click', async () => {
        const files = document.getElementById('mergeBackupFiles').files;
        if (!files.length) {
          showToast('Select at least one file.', true);
          return;
        }
        setSpinner(true);
        try {
          const merged = await mergeBackupFiles(files, document.getElementById('mergePrefix').value);
          const blob   = new Blob([JSON.stringify(merged, null, 2)], { type: 'application/json' });
          const url    = URL.createObjectURL(blob);
          const a      = document.createElement('a');
          a.href       = url;
          a.download   = 'merged_backup_file.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showToast('Files merged');
        } catch (err) {
          showToast(err.message, true);
        } finally {
          setSpinner(false);
        }
      });

      // Find & Replace logic
      let frData = null, frPtr = { scene: 0, block: 0, offset: 0 }, frMatch = null;

      function displayMatch(md) {
        document.getElementById('currentMatchDisplay').textContent = md
          ? `Match in "${md.chapterTitle}":\n${md.matchLine}`
          : 'No further matches found.';
      }

      function findNext() {
        const pat      = document.getElementById('findPattern').value;
        const useRegex = document.getElementById('useRegex').checked;
        if (!frData || !pat) return null;
        const scenes = frData.revisions[0].scenes;
        for (let i = frPtr.scene; i < scenes.length; i++) {
          const blocks = JSON.parse(scenes[i].text).blocks;
          for (let j = (i === frPtr.scene ? frPtr.block : 0); j < blocks.length; j++) {
            const txt = blocks[j].text || '';
            let start = (i === frPtr.scene && j === frPtr.block) ? frPtr.offset : 0;
            let idx   = -1;
            if (useRegex) {
              try {
                const rx = new RegExp(pat, 'g');
                rx.lastIndex = start;
                const m = rx.exec(txt);
                if (m) idx = m.index;
              } catch {
                showToast('Invalid regex.', true);
                return null;
              }
            } else {
              idx = txt.indexOf(pat, start);
            }
            if (idx !== -1) {
              const lines = txt.split('\n');
              let cum = 0, line = '';
              for (let L of lines) {
                if (idx >= cum && idx < cum + L.length) {
                  line = L;
                  break;
                }
                cum += L.length + 1;
              }
              frMatch = {
                sceneIndex: i,
                blockIndex: j,
                matchIndex: idx,
                chapterTitle: scenes[i].title,
                matchLine: line
              };
              frPtr = { scene: i, block: j, offset: idx + 1 };
              return frMatch;
            }
            frPtr.offset = 0;
          }
          frPtr = { scene: i + 1, block: 0, offset: 0 };
        }
        return null;
      }

      function findPrev() {
        const pat      = document.getElementById('findPattern').value;
        const useRegex = document.getElementById('useRegex').checked;
        if (!frData || !pat) return null;
        const scenes = frData.revisions[0].scenes;
        for (let i = frPtr.scene; i >= 0; i--) {
          const blocks = JSON.parse(scenes[i].text).blocks;
          for (let j = (i === frPtr.scene ? frPtr.block : blocks.length - 1); j >= 0; j--) {  
            const txt   = blocks[j].text || '';
            let endIdx  = (i === frPtr.scene ? frPtr.offset : txt.length);
            let idx     = -1;
            if (useRegex) {
              try {
                const rx = new RegExp(pat, 'g');
                let last = -1, m;
                while ((m = rx.exec(txt)) && m.index < endIdx) {
                  last = m.index;
                  if (rx.lastIndex === m.index) rx.lastIndex++;
                }
                idx = last;
              } catch {
                showToast('Invalid regex.', true);
                return null;
              }
            } else {
              idx = txt.lastIndexOf(pat, endIdx - 1);
            }
            if (idx !== -1) {
              const lines = txt.split('\n');
              let cum = 0, line = '';
              for (let L of lines) {
                if (idx >= cum && idx < cum + L.length) {
                  line = L;
                  break;
                }
                cum += L.length + 1;
              }
              frMatch = {
                sceneIndex: i,
                blockIndex: j,
                matchIndex: idx,
                chapterTitle: scenes[i].title,
                matchLine: line
              };
              frPtr = { scene: i, block: j, offset: idx };
              return frMatch;
            }
            frPtr.offset = (j > 0 ? txt.length : 0);
          }
          frPtr = { scene: i - 1, block: 0, offset: 0 };
        }
        return null;
      }

      document.getElementById('findNextBtn').addEventListener('click', () => {
        const inp = document.getElementById('frBackupFile');
        if (!frData) {
          if (!inp.files.length) {
            showToast('Upload a backup file first.', true);
            return;
          }
          const r = new FileReader();
          r.onload = e => {
            try {
              frData = JSON.parse(e.target.result);
              frPtr  = { scene: 0, block: 0, offset: 0 };
              displayMatch(findNext());
            } catch (err) {
              showToast(err.message, true);
            }
          };
          r.readAsText(inp.files[0]);
        } else {
          displayMatch(findNext());
        }
      });

      document.getElementById('findPreviousBtn').addEventListener('click', () => {
        const inp = document.getElementById('frBackupFile');
        if (!frData) {
          if (!inp.files.length) {
            showToast('Upload a backup file first.', true);
            return;
          }
          const r = new FileReader();
          r.onload = e => {
            try {
              frData = JSON.parse(e.target.result);
              const scenes = frData.revisions[0].scenes;
              frPtr = {
                scene: scenes.length - 1,
                block: 0,
                offset: JSON.parse(scenes[scenes.length - 1].text).blocks[0].text.length
              };
              displayMatch(findPrev());
            } catch (err) {
              showToast(err.message, true);
            }
          };
          r.readAsText(inp.files[0]);
        } else {
          displayMatch(findPrev());
        }
      });

      document.getElementById('replaceNextBtn').addEventListener('click', () => {
        if (!frData || !frMatch) {
          showToast('No match to replace.', true);
          return;
        }
        try {
          const pat      = document.getElementById('findPattern').value;
          const rep      = document.getElementById('replaceText').value;
          const useRegex = document.getElementById('useRegex').checked;
          const scene    = frData.revisions[0].scenes[frMatch.sceneIndex];
          const blocks   = JSON.parse(scene.text).blocks;
          let txt        = blocks[frMatch.blockIndex].text || '';
          const before   = txt.slice(0, frMatch.matchIndex);
          let after      = txt.slice(frMatch.matchIndex);
          after = useRegex
            ? after.replace(new RegExp(pat), rep)
            : after.replace(pat, rep);
          blocks[frMatch.blockIndex].text = before + after;
          scene.text = JSON.stringify({ blocks });
          frMatch    = null;
          showToast('Match replaced');
          displayMatch(findNext());
        } catch (err) {
          showToast(err.message, true);
        }
      });

      document.getElementById('replaceAllBtn').addEventListener('click', () => {
        const inp = document.getElementById('frBackupFile');
        if (!inp.files.length) {
          showToast('Upload a backup file first.', true);
          return;
        }
        setSpinner(true);
        const r = new FileReader();
        r.onload = e => {
          try {
            const backup = JSON.parse(e.target.result);
            const rev    = backup.revisions?.[0];
            if (!rev) throw new Error('Invalid backup structure.');
            const pat    = document.getElementById('findPattern').value;
            const rep    = document.getElementById('replaceText').value;
            const useRegex = document.getElementById('useRegex').checked;
            const replacer = useRegex
              ? txt => txt.replace(new RegExp(pat, 'g'), rep)
              : txt => txt.split(pat).join(rep);
            rev.scenes.forEach(scene => {
              const obj = JSON.parse(scene.text);
              obj.blocks.forEach(b => {
                if (typeof b.text === 'string') {
                  b.text = replacer(b.text);
                }
              });
              scene.text = JSON.stringify(obj);
            });
            const now = Date.now();
            backup.last_update_date = now;
            backup.last_backup_date = now;
            rev.date = now;
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = 'find_replace_backup_file.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('All replacements done');
          } catch (err) {
            showToast(err.message, true);
          } finally {
            setSpinner(false);
          }
        };
        r.readAsText(inp.files[0]);
      });
    });
  </script>
  <script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
      .then(reg => console.log('SW registered', reg.scope))
      .catch(err => console.error('SW registration failed', err));
  }
</script>
</body>
</html>
