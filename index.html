<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Novelist Tools</title>

  <!-- PWA manifest & theme color -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0097a7">

  <!-- iOS support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <style>
    /* === COMMON RESET & UI STYLES === */
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      margin:0; padding:0;
      background: linear-gradient(135deg,#1a1a1a,#0a0a0a);
      color:#e0e0e0; -webkit-font-smoothing:antialiased;
      font-size:16px; line-height:1.6;
    }
    header {
      display:flex; align-items:center;
      background:#111; padding:15px 20px;
      position:sticky; top:0; z-index:10;
    }
    .menu-toggle { font-size:24px; cursor:pointer; margin-right:20px; }
    .title { font-size:20px; font-weight:bold; color:#fff; }

    /* Sidebar */
    .sidebar {
      position:fixed; top:0; right:0;
      width:240px; height:100%; padding:20px;
      background:#222; box-shadow:-2px 0 8px rgba(0,0,0,0.5);
      transform:translateX(100%); transition:transform .3s ease;
      z-index:20; overflow-y:auto;
    }
    .sidebar.open { transform:translateX(0); }
    .sidebar h2 { color:#fff; margin:0 0 20px; }
    .sidebar button {
      width:100%; margin-bottom:15px; padding:12px;
      border:none; border-radius:8px;
      background:linear-gradient(135deg,#26c6da,#0097a7);
      color:#fff; font-size:16px; cursor:pointer;
      transition:all .3s;
    }
    .sidebar button:hover {
      transform:translateY(-2px);
      box-shadow:0 8px 16px rgba(255,255,255,0.1);
    }

    .container {
      max-width:480px; margin:20px auto; padding:0 20px;
    }
    .card {
      background:linear-gradient(145deg,#2a2a2a,#202020);
      padding:30px; border-radius:18px;
      box-shadow:0 4px 15px rgba(0,0,0,0.3),0 2px 6px rgba(0,0,0,0.2);
    }
    h1 {
      color:#fff; text-align:center;
      font-size:28px; margin-bottom:25px;
      text-shadow:0 2px 6px rgba(0,0,0,0.3);
    }

    .btn {
      width:100%; max-width:340px; margin:10px auto;
      padding:14px 30px; border:none; border-radius:12px;
      cursor:pointer; font-size:16px; font-weight:500;
      text-align:center; color:white;
      box-shadow:0 2px 4px rgba(0,0,0,0.1);
      transition:all .3s cubic-bezier(.25,.8,.25,1);
      display:block; box-sizing:border-box;
    }
    .btn:disabled {
      opacity:.6; cursor:not-allowed; transform:none;
      box-shadow:none;
    }

    /* EPUB Splitter Buttons */
    .upload-btn   { background:linear-gradient(135deg,#7e57c2,#5e37b5); }
    .split-btn    { background:linear-gradient(135deg,#26c6da,#0097a7); }
    .download-btn { background:linear-gradient(135deg,#ff7043,#e64a19); }

    .mode-section, .options-section {
      text-align:center; margin-bottom:25px;
    }
    .mode-section select,
    .option-group input,
    .option-group textarea {
      background:#2e2e2e; border:2px solid transparent;
      border-radius:8px; padding:12px; font-size:14px;
      color:#e0e0e0; width:100%; max-width:300px;
      margin:10px auto 0; box-sizing:border-box;
      transition:border-color .3s, box-shadow .3s;
    }
    .option-group { margin-bottom:15px; }
    .option-group label {
      display:block; color:#ffffffcc; margin-bottom:8px;
    }

    .spinner, .spinner-backup {
      border:5px solid rgba(255,255,255,0.1);
      border-top:5px solid #4a90e2;
      border-radius:50%; width:45px; height:45px;
      animation:spin 1.2s linear infinite;
      margin:20px auto; display:none;
    }
    @keyframes spin { to { transform:rotate(360deg); } }

    #statusMessage {
      border-radius:10px; padding:16px;
      margin-top:20px; animation:slideIn .3s ease-out;
    }
    @keyframes slideIn { from { opacity:0; transform:translateY(20px);} to { opacity:1; transform:translateY(0);} }

    /* Backup Utility Styles... (unchanged) */

    .status-toast {
      position:fixed; bottom:20px; left:50%;
      transform:translateX(-50%);
      padding:14px 24px; border-radius:8px;
      color:#fff; font-size:14px; opacity:0;
      pointer-events:none; transition:opacity .3s; z-index:1000;
    }
    .toast-success { background:#38a86d; }
    .toast-error   { background:#ff6b6b; }
  </style>
</head>

<body>
  <header>
    <div class="menu-toggle" onclick="toggleMenu()">â˜°</div>
    <div class="title" id="appTitle">EPUB Chapter Splitter</div>
  </header>

  <div class="sidebar" id="sidebar">
    <h2>Select Tool</h2>
    <button onclick="switchApp('splitter')">EPUB Chapter Splitter</button>
    <button onclick="switchApp('backup')">Novel Backup Utility</button>
  </div>

  <div class="container">
    <!-- EPUB Chapter Splitter -->
    <div id="splitterApp" class="card">
      <h1>EPUB Chapter Splitter</h1>

      <div class="upload-section">
        <label for="epubUpload" class="btn upload-btn">Upload EPUB File</label>
        <input type="file" id="epubUpload" accept=".epub" style="display:none;">
        <div id="epubFileName" style="margin-top:10px;font-size:14px;color:#ccc;text-align:center;"></div>
      </div>

      <div class="mode-section">
        <label for="modeSelect">Output Mode:</label>
        <select id="modeSelect">
          <option value="single">Single Chapter per File</option>
          <option value="grouped">Grouped Chapters per File</option>
        </select>
      </div>

      <div class="options-section">
        <div class="option-group">
          <label for="chapterPattern">Chapter Prefix:</label>
          <input type="text" id="chapterPattern" placeholder="e.g., test" value="test">
        </div>
        <div class="option-group">
          <label for="startNumber">Start Number:</label>
          <input type="number" id="startNumber" min="1" value="1">
        </div>
        <!-- Offset Mode -->
        <div class="option-group" id="offsetGroup">
          <label for="offsetNumber">Offset (skip chapters):</label>
          <input type="number" id="offsetNumber" min="0" value="0">
        </div>
        <!-- Preview & Range Mode -->
        <div class="option-group">
          <label>Selection Mode:</label>
          <label><input type="radio" name="selMode" value="offset" checked> Offset</label>
          <label><input type="radio" name="selMode" value="preview"> Preview & Range</label>
        </div>
        <div id="previewSection" style="display:none;
            max-height:200px; overflow-y:auto;
            border:1px solid #444; padding:10px;
            border-radius:8px; background:#2e2e2e; margin-bottom:15px;">
          <div class="option-group">
            <label for="rangeInput">Range (e.g., 5-20):</label>
            <input type="text" id="rangeInput" placeholder="5-20">
          </div>
          <ul id="chapterList" style="list-style:none;padding:0;margin:10px 0;">
            <!-- JS will populate -->
          </ul>
        </div>
        <div class="option-group" id="groupSizeGroup" style="display:none;">
          <label for="groupSize">Chapters per File:</label>
          <input type="number" id="groupSize" min="1" value="4">
        </div>
      </div>

      <button id="splitBtn" class="btn split-btn" disabled>Split EPUB</button>
      <div id="spinnerSplitter" class="spinner"></div>
      <div id="statusMessage" class="status" style="display:none;"></div>
      <div class="download-section" style="display:none;">
        <a id="downloadLink" class="btn download-btn">Download Chapters</a>
      </div>
    </div>

    <!-- Novel Backup Utility (unchanged) -->
    <div id="backupApp" class="card" style="display:none;">
      <!-- backup UI here... -->
    </div>
  </div>

  <!-- Install App Button -->
  <button id="installBtn" style="
    display:none;
    position:fixed; bottom:20px; right:20px;
    padding:12px 18px; background:#0097a7;
    color:white; border:none; border-radius:8px;
    font-size:16px; cursor:pointer;
  ">Install App</button>
  <div id="toast" class="status-toast"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    // Sidebar & PWA prompt
    function toggleMenu(){document.getElementById('sidebar').classList.toggle('open');}
    function switchApp(app){
      document.getElementById('splitterApp').style.display = app==='splitter'?'block':'none';
      document.getElementById('backupApp').style.display   = app==='backup'   ?'block':'none';
      document.getElementById('appTitle').textContent      = app==='splitter'?'EPUB Chapter Splitter':'Novel Backup File Utility';
      toggleMenu();
    }
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');
    window.addEventListener('beforeinstallprompt', e=>{
      e.preventDefault(); deferredPrompt = e; installBtn.style.display='block';
    });
    installBtn.addEventListener('click',async()=>{
      installBtn.style.display='none'; deferredPrompt.prompt(); deferredPrompt=null;
    });
    if('serviceWorker' in navigator){
      window.addEventListener('load',()=>{
        navigator.serviceWorker.register('service-worker.js')
          .then(reg=>console.log('SW registered:',reg.scope))
          .catch(console.error);
      });
    }

    /* EPUB Splitter Logic with Preview & Range */
    document.addEventListener('DOMContentLoaded',()=>{
      const epubInput  = document.getElementById('epubUpload');
      const fileNameEl = document.getElementById('epubFileName');
      const splitBtn   = document.getElementById('splitBtn');
      const modeSelect = document.getElementById('modeSelect');
      const offsetGroup= document.getElementById('offsetGroup');
      const grpSizeGrp = document.getElementById('groupSizeGroup');
      const previewSec = document.getElementById('previewSection');
      const chapterList= document.getElementById('chapterList');
      const spinner    = document.getElementById('spinnerSplitter');
      const statusEl   = document.getElementById('statusMessage');
      const downloadSec= document.querySelector('#splitterApp .download-section');
      const downloadLn = document.getElementById('downloadLink');
      let parsedChapters = [], selectedFile=null;

      // toggle group-size field
      modeSelect.addEventListener('change',()=>{
        grpSizeGrp.style.display = modeSelect.value==='grouped'?'block':'none';
      });

      // Switch between Offset vs Preview mode
      document.querySelectorAll('input[name="selMode"]').forEach(rb=>{
        rb.addEventListener('change',()=>{
          if(rb.value==='preview' && rb.checked){
            offsetGroup.style.display = 'none';
            previewSec.style.display  = 'block';
          } else if(rb.value==='offset' && rb.checked){
            offsetGroup.style.display = 'block';
            previewSec.style.display  = 'none';
          }
        });
      });

      // load file
      epubInput.addEventListener('change',e=>{
        selectedFile = e.target.files[0];
        if(!selectedFile) return;
        fileNameEl.textContent = `Selected: ${selectedFile.name}`;
        splitBtn.disabled = false;
        statusEl.style.display='none';
        downloadSec.style.display='none';
        chapterList.innerHTML=''; // clear
      });

      splitBtn.addEventListener('click',()=>{
        if(!selectedFile) return;
        spinner.style.display='block';
        statusEl.style.display='none';
        downloadSec.style.display='none';

        readFileAsArrayBuffer(selectedFile)
          .then(buf=>JSZip.loadAsync(buf))
          .then(epub=>{
            const struct={}, promises=[];
            epub.forEach((path,f)=>{
              struct[path]={dir:f.dir};
              if(!f.dir&&/\.(xhtml|html)$/.test(path)||/toc\.ncx|content\.opf/.test(path)){
                promises.push(f.async('text').then(txt=>struct[path].content=txt));
              }
            });
            return Promise.all(promises).then(()=>struct);
          })
          .then(struct=>{
            const chaps=[];
            Object.values(struct).forEach(info=>{
              if(info.content){
                let doc = new DOMParser().parseFromString(info.content,'text/xml');
                if(doc.querySelector('parsererror')){
                  doc=new DOMParser().parseFromString(info.content,'text/html');
                }
                const secs = doc.querySelectorAll(
                  'section[epub\\:type="chapter"],div[epub\\:type="chapter"],section.chapter,div.chapter'
                );
                if(secs.length){
                  secs.forEach(sec=>{
                    sec.querySelectorAll('h1,h2,h3,.title,.chapter-title').forEach(el=>el.remove());
                    const ps=sec.querySelectorAll('p'), text=ps.length
                      ?Array.from(ps).map(p=>p.textContent.trim()).filter(t=>t).join('\n')
                      :sec.textContent.replace(/\s*\n\s*/g,'\n').trim();
                    if(text) chaps.push(text);
                  });
                }
              }
            });
            parsedChapters = chaps;
            // populate preview list
            chapterList.innerHTML = parsedChapters.map((t,i)=>
              `<li>
                 <label>
                   <input type="checkbox" data-index="${i}">
                   Chapter ${i+1}: ${t.slice(0,50).replace(/\n/g,' ')}...
                 </label>
               </li>`
            ).join('');
            return parsedChapters;
          })
          .then(chapters=>{
            if(!chapters.length) throw new Error('No chapters found.');
            // read parameters
            const pattern  = document.getElementById('chapterPattern').value.trim()||'chapter';
            const startNum = parseInt(document.getElementById('startNumber').value,10)||1;
            const offset   = Math.max(0, parseInt(document.getElementById('offsetNumber').value,10)||0);
            const mode     = modeSelect.value;
            const selMode  = document.querySelector('input[name="selMode"]:checked').value;
            let usable=[];
            let effectiveStart = startNum;

            if(selMode==='offset'){
              usable = chapters.slice(offset);
              effectiveStart += offset;
            } else {
              // Preview & Range
              const range = document.getElementById('rangeInput').value.trim();
              if(range.match(/^\d+\s*-\s*\d+$/)){
                let [s,e]=range.split('-').map(x=>parseInt(x,10));
                s=Math.max(1,s); e=Math.min(chapters.length,e);
                for(let i=s-1;i<e;i++) usable.push(chapters[i]);
                effectiveStart = s;
              } else {
                document.querySelectorAll('#chapterList input[type=checkbox]:checked')
                  .forEach(cb=>usable.push(chapters[cb.dataset.index]));
                // for checked we preserve original order, numbering by original index+1
              }
            }

            const zip=new JSZip();
            if(mode==='single'){
              usable.forEach((text,i)=>{
                const num = String(effectiveStart + i).padStart(2,'0');
                zip.file(`${pattern}${num}.txt`,text);
              });
            } else {
              const gsz = parseInt(document.getElementById('groupSize').value,10)||1;
              for(let i=0;i<usable.length;i+=gsz){
                const gs = effectiveStart + i;
                const ge = Math.min(effectiveStart+i+gsz-1,effectiveStart+usable.length-1);
                const name = gs===ge
                  ?`${pattern} C${String(gs).padStart(2,'0')}.txt`
                  :`${pattern} C${String(gs).padStart(2,'0')}-${String(ge).padStart(2,'0')}.txt`;
                let content='';
                for(let j=0;j<gsz && i+j<usable.length;j++){
                  if(j>0) content+='\n---------------- END ----------------\n';
                  content+=usable[i+j];
                }
                zip.file(name,content);
              }
            }
            return zip.generateAsync({type:'blob'})
                      .then(blob=>({blob,count:usable.length}));
          })
          .then(({blob,count})=>{
            downloadLn.href     = URL.createObjectURL(blob);
            downloadLn.download = `${document.getElementById('chapterPattern').value||'chapter'}_chapters.zip`;
            downloadSec.style.display='block';
            statusEl.textContent = `Extracted ${count} chapters.`;
            statusEl.className   ='status success';
            statusEl.style.display='block';
          })
          .catch(err=>{
            statusEl.textContent = `Error: ${err.message}`;
            statusEl.className   ='status error';
            statusEl.style.display='block';
          })
          .finally(()=>{ spinner.style.display='none'; });
      });

      function readFileAsArrayBuffer(file){
        return new Promise((res,rej)=>{
          const r=new FileReader();
          r.onload=()=>res(r.result);
          r.onerror=()=>rej(new Error('Failed to read file'));
          r.readAsArrayBuffer(file);
        });
      }
    });

    /* ---- Backup Utility Logic ---- */
    document.addEventListener('DOMContentLoaded', () => {
      const toastEl = document.getElementById('toast');
      function showToast(msg, isError = false) {
        toastEl.textContent = msg;
        toastEl.className = 'status-toast ' + (isError ? 'toast-error' : 'toast-success');
        toastEl.style.opacity = '1';
        setTimeout(() => { toastEl.style.opacity = '0'; }, 3000);
      }
      const spinnerB = document.getElementById('spinnerBackup');
      function setSpinner(on) { spinnerB.style.display = on ? 'block' : 'none'; }

      const opSelect = document.getElementById('operationSelect');
      opSelect.addEventListener('change', () => {
        ['create','extend','merge','findReplace'].forEach(op => {
          document.getElementById(op + 'Section').style.display =
            opSelect.value === op ? 'block' : 'none';
        });
      });

      // Create new backup
      document.getElementById('createBtn').addEventListener('click', () => {
        setSpinner(true);
        try {
          const title      = document.getElementById('createProjectTitle').value;
          const desc       = document.getElementById('createDescription').value;
          const codeInput  = document.getElementById('createUniqueCode').value.trim();
          const count      = parseInt(document.getElementById('createChapters').value, 10) || 0;
          const prefix     = document.getElementById('createPrefix').value;
          const showTOC    = document.getElementById('createTOC').value === 'true';
          const autoIndent = document.getElementById('createIndentation').value === 'true';
          if (!title || !desc || count < 1) throw new Error('Please fill title, description, and at least 1 chapter.');

          const uniqueCode = codeInput ||
            Math.floor(Math.random() * 0xFFFFFFFF).toString(16).padStart(8, '0');
          const now = Date.now();
          const scenes   = [];
          const sections = [];
          for (let i = 1; i <= count; i++) {
            const chap = prefix ? prefix + i : i.toString();
            scenes.push({
              code: 'scene' + i, title: chap,
              text: JSON.stringify({ blocks: [{ type: 'text', align: 'left', text: '' }] }),
              ranking: i, status: '1'
            });
            sections.push({
              code: 'section' + i, title: chap,
              synopsis: '', ranking: i,
              section_scenes: [{ code: 'scene' + i, ranking: 1 }]
            });
          }
          const backup = {
            version: 4, code: uniqueCode, title, description: desc,
            show_table_of_contents: showTOC,
            apply_automatic_indentation: autoIndent,
            last_update_date: now, last_backup_date: now,
            revisions: [{
              number: 1, date: now,
              book_progresses: [{
                year: new Date().getFullYear(),
                month: new Date().getMonth() + 1,
                day: new Date().getDate(),
                word_count: 0
              }],
              statuses: [{ code: '1', title: 'Todo', color: -2697255, ranking: 1 }],
              scenes, sections
            }]
          };
          const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
          const url  = URL.createObjectURL(blob);
          const a    = document.createElement('a');
          a.href     = url;
          a.download = 'new_backup_file.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showToast('Backup file created');
        } catch (err) {
          showToast(err.message, true);
        } finally {
          setSpinner(false);
        }
      });

      // Extend existing backup
      document.getElementById('extendBtn').addEventListener('click', () => {
        const inp = document.getElementById('extendBackupFile');
        if (!inp.files.length) {
          showToast('Please upload a backup file.', true);
          return;
        }
        setSpinner(true);
        const extra  = parseInt(document.getElementById('extendExtraChapters').value, 10) || 0;
        const prefix = document.getElementById('extendPrefix').value;
        const reader = new FileReader();
        reader.onerror = () => {
          showToast('Error reading file.', true);
          setSpinner(false);
        };
        reader.onload = e => {
          try {
            const backup = JSON.parse(e.target.result);
            const rev    = backup.revisions?.[0];
            if (!rev) throw new Error('Invalid backup structure.');
            const existing = rev.scenes?.length || 0;
            for (let i = 1; i <= extra; i++) {
              const num  = existing + i;
              const chap = prefix ? prefix + num : num.toString();
              rev.scenes.push({
                code: 'scene' + num, title: chap,
                text: JSON.stringify({ blocks: [{ type: 'text', align: 'left', text: '' }] }),
                ranking: num, status: '1'
              });
              rev.sections.push({
                code: 'section' + num, title: chap,
                synopsis: '', ranking: num,
                section_scenes: [{ code: 'scene' + num, ranking: 1 }]
              });
            }
            const now = Date.now();
            backup.last_update_date = now;
            backup.last_backup_date = now;
            rev.date = now;
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = 'extended_backup_file.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Backup extended');
          } catch (err) {
            showToast(err.message, true);
          } finally {
            setSpinner(false);
          }
        };
        reader.readAsText(inp.files[0]);
      });

      // Merge backup files
      async function mergeBackupFiles(files, prefix) {
        let scenes   = [];
        let sections = [];
        for (let f of files) {
          const data = JSON.parse(await f.text());
          const rev  = data.revisions?.[0];
          if (rev?.scenes)    scenes   = scenes.concat(rev.scenes);
          if (rev?.sections)  sections = sections.concat(rev.sections);
        }
        scenes.forEach((s, i) => {
          const n = i + 1, t = prefix ? prefix + n : n.toString();
          s.code    = 'scene' + n;
          s.title   = t;
          s.ranking = n;
        });
        sections.forEach((s, i) => {
          const n = i + 1, t = prefix ? prefix + n : n.toString();
          s.code    = 'section' + n;
          s.title   = t;
          s.ranking = n;
          if (s.section_scenes?.[0]) {
            s.section_scenes[0].code    = 'scene' + n;
            s.section_scenes[0].ranking = 1;
          }
        });
        const now = Date.now();
        return {
          version: 4,
          code: Math.floor(Math.random() * 0xFFFFFFFF).toString(16).padStart(8, '0'),
          title: document.getElementById('mergeProjectTitle').value,
          description: document.getElementById('mergeDescription').value,
          show_table_of_contents: true,
          apply_automatic_indentation: true,
          last_update_date: now,
          last_backup_date: now,
          revisions: [{
            number: 1, date: now,
            statuses: [{ code: '1', title: 'Todo', color: -2697255, ranking: 1 }],
            scenes, sections
          }]
        };
      }

      document.getElementById('mergeBtn').addEventListener('click', async () => {
        const files = document.getElementById('mergeBackupFiles').files;
        if (!files.length) {
          showToast('Select at least one file.', true);
          return;
        }
        setSpinner(true);
        try {
          const merged = await mergeBackupFiles(files, document.getElementById('mergePrefix').value);
          const blob   = new Blob([JSON.stringify(merged, null, 2)], { type: 'application/json' });
          const url    = URL.createObjectURL(blob);
          const a      = document.createElement('a');
          a.href       = url;
          a.download   = 'merged_backup_file.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showToast('Files merged');
        } catch (err) {
          showToast(err.message, true);
        } finally {
          setSpinner(false);
        }
      });

      // Find & Replace logic
      let frData = null, frPtr = { scene: 0, block: 0, offset: 0 }, frMatch = null;

      function displayMatch(md) {
        document.getElementById('currentMatchDisplay').textContent = md
          ? `Match in "${md.chapterTitle}":\n${md.matchLine}`
          : 'No further matches found.';
      }

      function findNext() {
        const pat      = document.getElementById('findPattern').value;
        const useRegex = document.getElementById('useRegex').checked;
        if (!frData || !pat) return null;
        const scenes = frData.revisions[0].scenes;
        for (let i = frPtr.scene; i < scenes.length; i++) {
          const blocks = JSON.parse(scenes[i].text).blocks;
          for (let j = (i === frPtr.scene ? frPtr.block : 0); j < blocks.length; j++) {
            const txt = blocks[j].text || '';
            let start = (i === frPtr.scene && j === frPtr.block) ? frPtr.offset : 0;
            let idx   = -1;
            if (useRegex) {
              try {
                const rx = new RegExp(pat, 'g');
                rx.lastIndex = start;
                const m = rx.exec(txt);
                if (m) idx = m.index;
              } catch {
                showToast('Invalid regex.', true);
                return null;
              }
            } else {
              idx = txt.indexOf(pat, start);
            }
            if (idx !== -1) {
              const lines = txt.split('\n');
              let cum = 0, line = '';
              for (let L of lines) {
                if (idx >= cum && idx < cum + L.length) {
                  line = L; break;
                }
                cum += L.length + 1;
              }
              frMatch = {
                sceneIndex: i,
                blockIndex: j,
                matchIndex: idx,
                chapterTitle: scenes[i].title,
                matchLine: line
              };
              frPtr = { scene: i, block: j, offset: idx + 1 };
              return frMatch;
            }
            frPtr.offset = 0;
          }
          frPtr = { scene: i + 1, block: 0, offset: 0 };
        }
        return null;
      }

      function findPrev() {
        const pat      = document.getElementById('findPattern').value;
        const useRegex = document.getElementById('useRegex').checked;
        if (!frData || !pat) return null;
        const scenes = frData.revisions[0].scenes;
        for (let i = frPtr.scene; i >= 0; i--) {
          const blocks = JSON.parse(scenes[i].text).blocks;
          for (let j = (i === frPtr.scene ? frPtr.block : blocks.length - 1); j >= 0; j--) {
            const txt   = blocks[j].text || '';
            let endIdx  = (i === frPtr.scene ? frPtr.offset : txt.length);
            let idx     = -1;
            if (useRegex) {
              try {
                const rx = new RegExp(pat, 'g');
                let last = -1, m;
                while ((m = rx.exec(txt)) && m.index < endIdx) {
                  last = m.index;
                  if (rx.lastIndex === m.index) rx.lastIndex++;
                }
                idx = last;
              } catch {
                showToast('Invalid regex.', true);
                return null;
              }
            } else {
              idx = txt.lastIndexOf(pat, endIdx - 1);
            }
            if (idx !== -1) {
              const lines = txt.split('\n');
              let cum = 0, line = '';
              for (let L of lines) {
                if (idx >= cum && idx < cum + L.length) {
                  line = L; break;
                }
                cum += L.length + 1;
              }
              frMatch = {
                sceneIndex: i,
                blockIndex: j,
                matchIndex: idx,
                chapterTitle: scenes[i].title,
                matchLine: line
              };
              frPtr = { scene: i, block: j, offset: idx };
              return frMatch;
            }
            frPtr.offset = (j > 0 ? txt.length : 0);
          }
          frPtr = { scene: i - 1, block: 0, offset: 0 };
        }
        return null;
      }

      document.getElementById('findNextBtn').addEventListener('click', () => {
        const inp = document.getElementById('frBackupFile');
        if (!frData) {
          if (!inp.files.length) {
            showToast('Upload a backup file first.', true);
            return;
          }
          const r = new FileReader();
          r.onload = e => {
            try {
              frData = JSON.parse(e.target.result);
              frPtr  = { scene: 0, block: 0, offset: 0 };
              displayMatch(findNext());
            } catch (err) {
              showToast(err.message, true);
            }
          };
          r.readAsText(inp.files[0]);
        } else {
          displayMatch(findNext());
        }
      });

      document.getElementById('findPreviousBtn').addEventListener('click', () => {
        const inp = document.getElementById('frBackupFile');
        if (!frData) {
          if (!inp.files.length) {
            showToast('Upload a backup file first.', true);
            return;
          }
          const r = new FileReader();
          r.onload = e => {
            try {
              frData = JSON.parse(e.target.result);
              const scenes = frData.revisions[0].scenes;
              frPtr = {
                scene: scenes.length - 1,
                block: 0,
                offset: JSON.parse(scenes[scenes.length - 1].text).blocks[0].text.length
              };
              displayMatch(findPrev());
            } catch (err) {
              showToast(err.message, true);
            }
          };
          r.readAsText(inp.files[0]);
        } else {
          displayMatch(findPrev());
        }
      });

      document.getElementById('replaceNextBtn').addEventListener('click', () => {
        if (!frData || !frMatch) {
          showToast('No match to replace.', true);
          return;
        }
        try {
          const pat      = document.getElementById('findPattern').value;
          const rep      = document.getElementById('replaceText').value;
          const useRegex = document.getElementById('useRegex').checked;
          const scene    = frData.revisions[0].scenes[frMatch.sceneIndex];
          const blocks   = JSON.parse(scene.text).blocks;
          let txt        = blocks[frMatch.blockIndex].text || '';
          const before   = txt.slice(0, frMatch.matchIndex);
          let after      = txt.slice(frMatch.matchIndex);
          after = useRegex
            ? after.replace(new RegExp(pat), rep)
            : after.replace(pat, rep);
          blocks[frMatch.blockIndex].text = before + after;
          scene.text = JSON.stringify({ blocks });
          frMatch    = null;
          showToast('Match replaced');
          displayMatch(findNext());
        } catch (err) {
          showToast(err.message, true);
        }
      });

      document.getElementById('replaceAllBtn').addEventListener('click', () => {
        const inp = document.getElementById('frBackupFile');
        if (!inp.files.length) {
          showToast('Upload a backup file first.', true);
          return;
        }
        setSpinner(true);
        const r = new FileReader();
        r.onload = e => {
          try {
            const backup = JSON.parse(e.target.result);
            const rev    = backup.revisions?.[0];
            if (!rev) throw new Error('Invalid backup structure.');
            const pat    = document.getElementById('findPattern').value;
            const rep    = document.getElementById('replaceText').value;
            const useRegex = document.getElementById('useRegex').checked;
            const replacer = useRegex
              ? txt => txt.replace(new RegExp(pat, 'g'), rep)
              : txt => txt.split(pat).join(rep);
            rev.scenes.forEach(scene => {
              const obj = JSON.parse(scene.text);
              obj.blocks.forEach(b => {
                if (typeof b.text === 'string') {
                  b.text = replacer(b.text);
                }
              });
              scene.text = JSON.stringify(obj);
            });
            const now = Date.now();
            backup.last_update_date = now;
            backup.last_backup_date = now;
            rev.date = now;
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = 'find_replace_backup_file.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('All replacements done');
          } catch (err) {
            showToast(err.message, true);
          } finally {
            setSpinner(false);
          }
        };
        r.readAsText(inp.files[0]);
      });
    });
  </script>
</body>
</html>
